# JVM

## 1. 简介

### 1.1 学习重点

![image-20200511112833433](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200511112833433.png)

* 主要调优都是在 **方法区** 和 **堆**

## 2. ClassLoader 类加载器

* 加载class文件

### 2.1 其他类加载器

* #### BootstrapClassLoader C++编写，加载java核心库 **不允许直接访问**

* #### ExtClassLoader java编写，加载扩展库

* #### AppClassLoader 加载程序所在的目录，自定义的类

* #### CustomClassLoader 加载自定义类加载器

层级向上 类加载器--> 扩展类 --> 应用类

### 2.2 双亲委派机制

为了安全，防止程序员自己写的类和JDK自带的类重复。

* 当类加载器收到了加载类的请求
* 会委托给父类进行查找，如果没有，继续向上委托。找到即终止
* 启动加载器检查是否可以加载，能加载则结束，不能则抛出异常，通知子加载器加载 Class Not Found
* 重复3 

#### 2.2.1 流程图

* 向上逐级查找该类是否已经被这一级别的类加载器加载过了，如果加载过了则停止，直接创建改类。
* 如果都没有，那么开始从上到下加载该级别加载器可以加载的类（所以会优先Java核心加载类）

![image-20200511122245962](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200511122245962.png)

## 3. 沙箱安全机制

## 4. Native 关键字

这个关键字的说明java的作用范围打不到了，需要去调用底层C语言的例子。

* 会进入本地方法栈，并且通过JNI (JAVA Native Interface) 来调用本地方法接口

## 5. 方法区

共享区域 存放如下

* static 
* final 
* class 
* 常量池

## 6. 栈

生命周期和线程同步，线程结束内存就释放，不存在垃圾回收机制，存放

* 8大基本数据类型
* 对象引用地址
* 实例的方法

#### 6.1 结构

![image-20200512073016042](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200512073016042.png)

* 每个方法运行会有一套这样的数据
* 当前执行的一定在栈顶
* 用完后则会弹出 所以不会有垃圾回收机制

## 7. 三种JVM

* sun公司的 Hotspot 常用
* 剩下两个了解而已

## 8. 堆

一个JVM只有一个堆

### 8.1 结构

![image-20200512092926042](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200512092926042.png)

### 8.2 各个区

* 类诞生成长甚至死亡的地方
* 伊甸园：创建类的新的实例在这里创建，满了后触发**轻GC**
* 幸存区：从伊甸园中幸存的（仍然被使用的）存放在这里
* 养老区：如果上面两个都满了，触发**重GC**，把上面两个的幸存的放到养老区。
* 永久区（元空间/老年区）
  * 1.6之前 :永久代，常量池是放在方法区；
  * 1.7： 永久代，但是慢慢退化了，去永久代，常量池在堆中
  * 1.8之后：无永久代，常量池在元空间中
  * 这个区域常驻内存，用来存放JDK自身携带的一些class interface 存储的是java运行环境
  * 不存在GC,关闭VM才会释放

### 8.3 堆内存调优（OOM）

元空间：逻辑存在，物理不存在

## 9. GC （分代收集算法）

作用区域 ：

* 方法区
* 堆
  * 新生代
  * 幸存区
  * 老年区

### 9.1 轻GC & 重GC

### 9.2 GC常用算法

#### 9.2.1 引用计数法（不太用）

给每个变量的引用计数 按照轻重缓急清理

![image-20200512100936617](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200512100936617.png)

#### 9.2.2 赋值算法

![image-20200512101921647](/Users/bohanxiao/Library/Application Support/typora-user-images/image-20200512101921647.png)

1. GC开始 **伊甸区**和**非空的**那个幸存区会把没有被清除的放到空的**幸存区**里面
2. 如果经历过15次仍然活着的，那么就会被放到**老年区**里面。

好处：没有内存碎片

坏处：浪费了一半的幸存区内存

最佳场景：对象存活度比较低。

#### 9.2.3 标记清除法

扫描内存，标记需要**存活的**的，第二次再扫描**清除**所有没有被标记的

优点：不需要额外的空间

缺点：两次扫描，浪费时间，并且有内存碎片，因为是标记。

#### 9.2.4 标记压缩

在标记清楚的基础上再进行一次扫描用来把**零散的没有被清除的**重新压缩到一起从而增加速度

缺点：又多了一次扫描成本。

### 9.3 总结

内存效率：复制算法 >  标记清除法 > 标记压缩算法 （时间复杂度）

内存整齐度：复制算法 = 标记压缩算法 > 标记清除算法

内存利用率： 标记压缩算法= 标记清除算法 > 复制算法



年轻代：

* 存活率低
* 复制算法

老年代：

* 区域大：存活率
* 标记清除 + 标记压缩混合

**这就是为啥GC是分代收集算法**

## 10. JMM

Java Memory Model

### 10.1 简介

和很多**协议**有关，用来处理**缓存一致性**。

